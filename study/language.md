# プログラミング言語学習ガイドプロンプト

このドキュメントは、プログラミング言語を体系的に習得するためのガイドプロンプト集です。
習熟度を「基礎」「応用」「発展」の 3 段階に分け、各段階で習得すべき知識と、AI に質問する際のプロンプトテンプレートを提供します。

---

## 使い方

1. 学習したい言語を `{言語名}` に置き換えてください
2. 各セクションのプロンプトを AI に投げかけて学習を進めてください
3. 基礎 → 応用 → 発展の順に進めることを推奨しますが、必要に応じて行き来してください

---

## 🟢 基礎レベル（Foundation）

### 目標

言語の基本構文と標準機能を理解し、簡単なプログラムを書けるようになる。

---

### 1. 言語の概要と設計思想

```
{言語名}について、以下の観点から概要を教えてください：

1. **設計思想・哲学**
   - この言語が解決しようとしている問題は何か
   - 言語設計者が重視した価値観（安全性、パフォーマンス、生産性など）

2. **主な用途・適用領域**
   - どのような分野で使われているか
   - 代表的なユースケース

3. **実行モデル**
   - コンパイル型/インタプリタ型/ハイブリッド型のどれか
   - 実行環境（VM、ネイティブ、ブラウザなど）

4. **型システム**
   - 静的型付け/動的型付け
   - 強い型付け/弱い型付け
```

---

### 2. 組み込みデータ型

```
{言語名}の組み込みデータ型について、以下を詳しく教えてください：

1. **プリミティブ型**
   - 数値型（整数、浮動小数点、それぞれのビット幅とオーバーフロー挙動）
   - 文字・文字列型（エンコーディング、イミュータブルかどうか）
   - 真偽値型
   - null/nil/undefined に相当する型

2. **リテラル表記**
   - 各型のリテラル記法と特殊な表記（アンダースコア区切り、進数表記など）

3. **型変換**
   - 暗黙的な型変換のルール
   - 明示的な型変換の方法
   - 変換時の注意点（精度損失、オーバーフローなど）

具体的なコード例を交えて説明してください。
```

---

### 3. 変数と定数

```
{言語名}の変数と定数について、以下を詳しく教えてください：

1. **宣言と初期化**
   - 変数宣言のキーワードと構文
   - 型推論の有無と動作
   - 初期化が必須かどうか

2. **スコープ**
   - スコープの種類（グローバル、ローカル、ブロック、関数など）
   - シャドーイングのルール
   - スコープの可視性ルール

3. **可変性**
   - 定数（イミュータブル）の宣言方法
   - 再代入と可変性の区別
   - コンパイル時定数と実行時定数

4. **命名規則**
   - 言語が推奨する命名規則（キャメルケース、スネークケースなど）
   - 予約語と識別子のルール

具体的なコード例を交えて説明してください。
```

---

### 4. データ構造

```
{言語名}の標準的なデータ構造について、以下を詳しく教えてください：

1. **配列・リスト**
   - 固定長配列と可変長リストの違い
   - 宣言・初期化・アクセス方法
   - スライス操作

2. **マップ・辞書・ハッシュ**
   - 宣言・初期化・アクセス方法
   - キーに使える型の制約
   - 順序保証の有無

3. **セット・集合**
   - 宣言・初期化・操作方法
   - 集合演算（和、積、差）

4. **タプル・構造体**
   - タプル（あれば）の使い方
   - 構造体/レコード型の定義方法

5. **標準ライブラリのコレクション**
   - よく使われるコレクション型（スタック、キュー、優先度キューなど）

各データ構造について、
- 時間計算量（挿入、削除、検索）
- メモリ効率
- 適切なユースケース
も合わせて教えてください。
```

---

### 5. 演算子

```
{言語名}の演算子について、以下を詳しく教えてください：

1. **算術演算子**
   - 基本演算（+, -, *, /, %など）
   - 整数除算と浮動小数点除算の違い
   - べき乗演算子

2. **比較演算子**
   - 等価比較（==, === などの違いがあれば）
   - 順序比較
   - 参照の比較と値の比較

3. **論理演算子**
   - AND, OR, NOT
   - 短絡評価の挙動

4. **ビット演算子**
   - ビット演算子の一覧と使い方

5. **代入演算子**
   - 複合代入演算子
   - 分割代入（デストラクチャリング）

6. **その他の演算子**
   - 三項演算子
   - null合体演算子（あれば）
   - 範囲演算子（あれば）
   - パターンマッチング演算子（あれば）

7. **演算子の優先順位**
   - 優先順位表と結合規則

具体的なコード例を交えて説明してください。
```

---

### 6. 制御文

```
{言語名}の制御文について、以下を詳しく教えてください：

1. **条件分岐**
   - if/else 文の構文
   - switch/case/match 文（あれば）
   - 条件式で使える型と暗黙の真偽値変換

2. **ループ**
   - for ループ（カウンタ型、イテレータ型）
   - while / do-while ループ
   - 無限ループのイディオム
   - break / continue の挙動
   - ラベル付きループ（あれば）

3. **イテレーション**
   - イテレータ/ジェネレータの概念
   - for-each / for-in / for-of などの違い

4. **パターンマッチング**
   - パターンマッチング機能（あれば）
   - ガード条件

5. **例外処理との組み合わせ**
   - try-catch-finally ブロックと制御フローの関係

具体的なコード例を交えて説明してください。
```

---

### 7. 関数

```
{言語名}の関数について、以下を詳しく教えてください：

1. **関数の定義**
   - 基本的な関数定義の構文
   - 戻り値の型指定
   - 複数の戻り値（あれば）

2. **引数**
   - 位置引数とキーワード引数
   - デフォルト引数
   - 可変長引数
   - 値渡しと参照渡し

3. **関数型プログラミング機能**
   - 第一級関数
   - 高階関数
   - ラムダ式/無名関数/クロージャ
   - 関数合成

4. **特殊な関数**
   - ジェネレータ関数（あれば）
   - 非同期関数（あれば）
   - 再帰関数と末尾再帰最適化

5. **オーバーロード**
   - 関数オーバーロードのサポート状況
   - オーバーロード解決のルール

具体的なコード例を交えて説明してください。
```

---

### 8. クラスとオブジェクト

```
{言語名}のクラスとオブジェクト指向について、以下を詳しく教えてください：

1. **クラス定義**
   - クラスの宣言構文
   - コンストラクタ/デストラクタ
   - フィールド（プロパティ）の定義

2. **アクセス修飾子**
   - public / private / protected などの可視性
   - モジュールレベルの可視性

3. **継承**
   - 単一継承/多重継承
   - インターフェース/プロトコル/トレイト
   - 抽象クラス

4. **ポリモーフィズム**
   - メソッドオーバーライド
   - 動的ディスパッチの仕組み
   - 型のアップキャスト/ダウンキャスト

5. **その他のOOP機能**
   - static メンバー
   - コンパニオンオブジェクト（あれば）
   - 拡張関数/メソッド（あれば）
   - mixin（あれば）

6. **オブジェクトの同一性と等価性**
   - 参照の比較と値の比較
   - equals / hashCode 相当の実装

具体的なコード例を交えて説明してください。
```

---

### 9. エラー処理

```
{言語名}のエラー処理について、以下を詳しく教えてください：

1. **エラー処理のパラダイム**
   - 例外ベース / Result型ベース / エラーコードベース
   - 言語が推奨するエラー処理パターン

2. **例外処理（例外ベースの場合）**
   - try-catch-finally の構文
   - 例外の種類（チェック例外/非チェック例外）
   - カスタム例外の定義
   - 例外の再スロー
   - スタックトレースの取得

3. **Result型/Option型（ある場合）**
   - Result/Either/Option型の使い方
   - モナド的な連鎖処理
   - アンラップの方法と安全性

4. **パニック/クラッシュ**
   - 回復不能なエラーの扱い
   - panic / assert / abort

5. **ベストプラクティス**
   - エラー処理のイディオム
   - アンチパターン（やってはいけないこと）

具体的なコード例を交えて説明してください。
```

---

### 10. モジュールとパッケージ

```
{言語名}のモジュールシステムについて、以下を詳しく教えてください：

1. **モジュール/パッケージの概念**
   - モジュールとパッケージの違い（あれば）
   - ファイルとモジュールの関係

2. **インポート/エクスポート**
   - シンボルのエクスポート方法
   - インポートの構文（選択的インポート、エイリアス、ワイルドカード）
   - 循環インポートの扱い

3. **可視性**
   - モジュール内/外の可視性制御
   - 内部実装の隠蔽方法

4. **パッケージマネージャ**
   - 標準的なパッケージマネージャ
   - 依存関係の管理方法
   - バージョン指定の方法

5. **プロジェクト構成**
   - 推奨されるディレクトリ構造
   - ビルドシステムとの連携

具体的なコード例を交えて説明してください。
```

---

### 11. その他の基礎機能

```
{言語名}の以下の機能について、サポート状況と使い方を教えてください：

1. **ジェネリクス/テンプレート**
   - 型パラメータの基本構文
   - 型制約/境界の指定方法

2. **並行処理/並列処理**
   - スレッド/コルーチン/アクター
   - 非同期プログラミングモデル（async/await など）
   - 同期プリミティブ（ミューテックス、セマフォなど）

3. **メタプログラミング**
   - リフレクション
   - マクロ
   - コード生成

4. **テスト**
   - 標準のテストフレームワーク
   - ユニットテストの書き方
   - モックとスタブ

5. **ドキュメンテーション**
   - ドキュメントコメントの形式
   - ドキュメント生成ツール

具体的なコード例を交えて説明してください。
```

---

## 🟡 応用レベル（Intermediate）

### 目標

言語の内部動作を理解し、パフォーマンスを意識したコードが書けるようになる。

---

### 1. 宣言と実行の内部動作

```
{言語名}で変数、関数、クラスを宣言すると、内部で何が起こるのか詳しく教えてください：

1. **変数宣言**
   - メモリ上でどのように領域が確保されるか
   - スタックとヒープのどちらに配置されるか
   - 初期化のタイミングと未初期化変数の扱い

2. **関数宣言**
   - 関数テーブル/vtableへの登録
   - クロージャの場合のキャプチャ変数の扱い
   - 呼び出し規約（calling convention）

3. **クラス/オブジェクトの生成**
   - インスタンス生成時のメモリレイアウト
   - vtable/ディスパッチテーブルの構造
   - 継承時のメモリ配置

4. **スコープとライフタイム**
   - スコープを抜けた時の挙動
   - ライフタイムの管理方法

実際のメモリ配置やアセンブリレベルでの動作も含めて説明してください。
```

---

### 2. コンパイルと最適化

```
{言語名}のコンパイル/実行過程について、以下を詳しく教えてください：

1. **コンパイルパイプライン**
   - 字句解析 → 構文解析 → 意味解析 → 中間表現 → 最適化 → コード生成
   - 各段階で何が行われるか

2. **主要な最適化手法**
   - インライン展開
   - 定数畳み込み
   - デッドコード除去
   - ループ最適化（アンローリング、ベクトル化）
   - エスケープ解析
   - JITコンパイル（該当する場合）

3. **最適化を妨げるコードパターン**
   - コンパイラが最適化できないパターン
   - パフォーマンスを意識したコーディング

4. **最適化レベルとトレードオフ**
   - コンパイラオプションの意味
   - デバッグビルドとリリースビルドの違い

5. **生成コードの確認方法**
   - アセンブリ出力の取得方法
   - 逆アセンブルの方法

具体的な例を交えて説明してください。
```

---

### 3. メモリ管理

```
{言語名}のメモリ管理について、以下を詳しく教えてください：

1. **メモリモデル**
   - スタック/ヒープ/静的領域の使い分け
   - 各データがどこに配置されるか

2. **メモリ使用量の把握**
   - プログラムのメモリ占有量の測定方法
   - メモリプロファイリングツール
   - 各オブジェクトのメモリサイズの計算方法

3. **メモリ内容の観察**
   - デバッガでのメモリ内容確認
   - メモリダンプの取得と解析

4. **メモリリークの検出**
   - メモリリークの一般的な原因
   - 検出ツールと手法
   - 修正方法

5. **メモリ効率の最適化**
   - メモリアロケーションの削減テクニック
   - オブジェクトプーリング
   - メモリアライメント

具体的なツールの使い方とコード例を交えて説明してください。
```

---

### 4. ガベージコレクション（該当する場合）

```
{言語名}のガベージコレクション（GC）について、以下を詳しく教えてください：

1. **GCの種類とアルゴリズム**
   - 使用しているGCアルゴリズム（マーク&スイープ、世代別、参照カウントなど）
   - 各アルゴリズムの長所と短所

2. **GCの動作タイミング**
   - GCがトリガーされる条件
   - Stop-the-World の発生タイミングと影響

3. **GCのチューニング**
   - GC関連の設定パラメータ
   - ヒープサイズの調整
   - GCログの取得と分析

4. **GCに優しいコード**
   - GC負荷を減らすコーディングパターン
   - オブジェクト生成の削減
   - ファイナライザ/デストラクタの注意点

5. **GCがない場合のメモリ管理**
   - 手動メモリ管理の方法
   - 所有権システム（Rustの場合）
   - スマートポインタ

具体的な例を交えて説明してください。
```

---

### 5. ジェネリクスの深掘り

```
{言語名}のジェネリクスについて、以下を詳しく教えてください：

1. **型パラメータの変性（Variance）**
   - 共変性（Covariance）のサポート状況と例
   - 反変性（Contravariance）のサポート状況と例
   - 不変性（Invariance）
   - 変性の指定方法（in/out キーワードなど）

2. **型消去 vs 型具象化**
   - ジェネリクスの実装方式
   - 実行時に型情報が利用可能か
   - 制限事項（型消去の場合）

3. **ジェネリクスの最適化**
   - 単相化（Monomorphization）の有無
   - ボクシング/アンボクシングの発生
   - パフォーマンスへの影響

4. **高度なジェネリクス機能**
   - 型制約/境界の詳細
   - 関連型（Associated Types）
   - 高カインド型（Higher-Kinded Types）
   - 再帰的な型制約

5. **ジェネリクスのベストプラクティス**
   - 適切な使用場面
   - 過度なジェネリクスの問題
   - 型推論との相互作用

具体的なコード例を交えて説明してください。
```

---

### 6. 並行処理の深掘り

```
{言語名}の並行処理について、以下を詳しく教えてください：

1. **メモリモデル**
   - 言語のメモリモデル仕様
   - happens-before 関係
   - 可視性の保証

2. **同期プリミティブ**
   - ロック（ミューテックス、リーダーライターロック）
   - アトミック操作
   - メモリバリア/フェンス
   - 条件変数/シグナル

3. **並行処理パターン**
   - プロデューサー・コンシューマー
   - Future/Promise
   - Actor モデル
   - CSP（Communicating Sequential Processes）

4. **デッドロックと競合状態**
   - 発生原因と検出方法
   - 回避パターン
   - デバッグツール

5. **パフォーマンス考慮**
   - ロックの粒度
   - ロックフリーアルゴリズム
   - スレッドプール設計

具体的なコード例を交えて説明してください。
```

---

### 7. パフォーマンス分析

```
{言語名}のパフォーマンス分析について、以下を詳しく教えてください：

1. **プロファイリングツール**
   - CPU プロファイラの使い方
   - メモリプロファイラの使い方
   - フレームグラフの読み方

2. **ベンチマーキング**
   - マイクロベンチマークの書き方
   - 注意点（ウォームアップ、外れ値など）
   - 標準的なベンチマークフレームワーク

3. **ホットスポットの特定**
   - ボトルネックの見つけ方
   - よくあるパフォーマンス問題

4. **最適化テクニック**
   - アルゴリズム/データ構造の選択
   - キャッシュ効率
   - 分岐予測への配慮
   - SIMD の活用

5. **パフォーマンス回帰テスト**
   - CI/CD でのパフォーマンステスト
   - パフォーマンス指標の監視

具体的なツールの使い方と例を交えて説明してください。
```

---

## 🔴 発展レベル（Advanced）

### 目標

言語設計とプログラミングパラダイムを深く理解し、言語の限界を知った上で最適な設計ができる。

---

### 1. プログラミングパラダイムの比較

```
{言語名}を以下のプログラミングパラダイムの観点から深く分析してください：

1. **命令型プログラミング**
   - 言語でのサポート状況
   - 典型的なパターンとイディオム
   - 状態管理のベストプラクティス

2. **宣言型プログラミング**
   - 言語でのサポート状況
   - SQL風のクエリ構文（LINQ、Comprehension など）
   - 設定ベースのプログラミング

3. **関数型プログラミング**
   - 純粋関数と副作用の分離
   - イミュータビリティのサポート
   - 代数的データ型
   - パターンマッチング
   - 高階関数とカリー化
   - モナド/ファンクタ（該当する場合）

4. **オブジェクト指向プログラミング**
   - SOLID原則の適用
   - デザインパターンの実装
   - 継承 vs 合成

5. **パラダイムの組み合わせ**
   - マルチパラダイム言語としての特性
   - 各パラダイムの使い分け指針

具体的なコード例を交えて説明してください。
```

---

### 2. 言語の型システム深掘り

```
{言語名}の型システムについて、以下を詳しく教えてください：

1. **型システムの理論的基礎**
   - 型の健全性（Type Soundness）
   - 型推論アルゴリズム（Hindley-Milner など）
   - サブタイピングのルール

2. **高度な型機能**
   - 依存型（Dependent Types）のサポート
   - 型レベルプログラミング
   - ファントム型
   - 存在型

3. **型の表現力と制限**
   - 型システムで表現できること/できないこと
   - 型安全性とエスケープハッチ

4. **型駆動開発**
   - 型を使った設計手法
   - Phantom Types パターン
   - Type State パターン

具体的なコード例を交えて説明してください。
```

---

### 3. メタプログラミングと DSL

```
{言語名}のメタプログラミングについて、以下を詳しく教えてください：

1. **マクロシステム**
   - マクロの種類と機能
   - マクロの衛生性（Hygiene）
   - マクロのデバッグ方法

2. **コンパイル時計算**
   - コンパイル時評価（constexpr など）
   - コンパイル時コード生成

3. **リフレクションとイントロスペクション**
   - 実行時型情報
   - メタデータの取得と操作
   - 動的なメソッド呼び出し

4. **DSL（ドメイン特化言語）の構築**
   - 内部DSLの作成テクニック
   - 演算子オーバーロードの活用
   - ビルダーパターン

5. **コード生成**
   - ソースコード生成ツール
   - アノテーション/属性プロセッサ

具体的なコード例を交えて説明してください。
```

---

### 4. 言語の限界と回避策

```
{言語名}の限界と回避策について、以下を詳しく教えてください：

1. **言語の既知の制限事項**
   - 型システムの制限
   - パフォーマンスの限界
   - 表現力の限界

2. **一般的な落とし穴**
   - よくある間違いとその原因
   - 言語特有の罠

3. **回避策とワークアラウンド**
   - 制限を回避するテクニック
   - サードパーティライブラリの活用

4. **他言語との相互運用**
   - FFI（Foreign Function Interface）
   - C言語との連携
   - 他言語バインディング

5. **言語の進化**
   - 言語の今後の方向性
   - 提案中の新機能
   - 非推奨になった機能

具体的な例を交えて説明してください。
```

---

### 5. 実践的な設計パターン

```
{言語名}での設計パターンについて、以下を詳しく教えてください：

1. **言語特有のイディオム**
   - この言語らしい書き方
   - 他言語から移ってきた人が陥りやすいアンチパターン

2. **アーキテクチャパターン**
   - 大規模アプリケーションの設計
   - モジュール分割の指針
   - 依存性注入

3. **エラーハンドリングパターン**
   - この言語でのエラー処理のベストプラクティス
   - エラーの伝搬と変換

4. **並行処理パターン**
   - この言語に適した並行処理設計
   - 並行処理のアンチパターン

5. **テスト容易性を考慮した設計**
   - テスタブルなコード設計
   - モック/スタブの作成方法

具体的なコード例を交えて説明してください。
```

---

## 📚 総合演習プロンプト

### 言語横断的な比較

```
{言語1}と{言語2}を以下の観点から比較してください：

1. 設計思想の違い
2. 型システムの違い
3. メモリ管理の違い
4. 並行処理モデルの違い
5. エコシステムの違い
6. それぞれの言語が得意とするユースケース
7. 移行時の注意点

具体的なコード例を交えて説明してください。
```

---

### 学習ロードマップの作成

```
{言語名}を習得するための学習ロードマップを作成してください：

1. **前提知識**
   - この言語を学ぶ前に知っておくべきこと

2. **基礎段階（1-2ヶ月）**
   - 習得すべきトピック
   - 推奨される教材/リソース
   - 実践プロジェクト案

3. **応用段階（2-4ヶ月）**
   - 習得すべきトピック
   - 推奨される教材/リソース
   - 実践プロジェクト案

4. **発展段階（4ヶ月以降）**
   - 習得すべきトピック
   - 推奨される教材/リソース
   - 実践プロジェクト案

5. **継続的な学習**
   - フォローすべきブログ/ポッドキャスト
   - コミュニティへの参加
   - オープンソースへの貢献
```

---

## 🔧 クイックリファレンスプロンプト

```
{言語名}のクイックリファレンスを作成してください。以下を含めてください：

1. 基本構文チートシート
2. よく使う標準ライブラリ関数
3. デバッグ時に役立つコマンド/関数
4. パフォーマンス測定の基本コマンド
5. よくあるエラーメッセージと解決方法
```

---

## 使用上のヒント

1. **段階的に進める**: 基礎をしっかり固めてから応用に進みましょう
2. **実際にコードを書く**: プロンプトの回答を読むだけでなく、実際にコードを書いて試しましょう
3. **比較学習**: 他の言語を知っている場合は、違いを意識しながら学びましょう
4. **定期的な復習**: 一度学んだ内容も定期的に復習しましょう
5. **実プロジェクトへの適用**: 学んだ内容を実際のプロジェクトで使ってみましょう
